//
//  C to Swift Mapping generated by a custom BNF Converter from Jan Wittler
//
//  This converter assumes files generated with BNFC 2.8.1, GNU Bison 2.3 and Flex 2.5.35
//  Compatibility with other versions can not be guaranteed
//

import CGrammar

public func parseFile(at path: Swift.String) -> Program? {
    if let file = fopen(path, "r") {
        defer { fclose(file) }
        if let cTree = CGrammar.pProgram(file) {
            return visitProgram(cTree)
        }
    }
    return nil
}

//MARK:- C to Swift mapping

private func visitArg(_ pValue: CGrammar.Arg) -> Arg {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .decl(visitId(value.u.argdecl_.id_), visitType(value.u.argdecl_.type_))
    default:
        print("Error: bad `kind` field when bridging `Arg` to Swift!")
        exit(1)
    }
}

private func visitListArg(_ pValue: CGrammar.ListArg?) -> [Arg] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.arg_ == nil {
        return []
    }
    return [visitArg(value.arg_)] + visitListArg(value.listarg_)
}

private func visitSwitchCase(_ pValue: CGrammar.SwitchCase) -> SwitchCase {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .`default`(visitIdMaybeTyped(value.u.switchcasedefault_.idmaybetyped_), visitCase(value.u.switchcasedefault_.case_), visitListStm(value.u.switchcasedefault_.liststm_))
    default:
        print("Error: bad `kind` field when bridging `SwitchCase` to Swift!")
        exit(1)
    }
}

private func visitListSwitchCase(_ pValue: CGrammar.ListSwitchCase?) -> [SwitchCase] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.switchcase_ == nil {
        return []
    }
    return [visitSwitchCase(value.switchcase_)] + visitListSwitchCase(value.listswitchcase_)
}

private func visitCoreType(_ pValue: CGrammar.CoreType) -> CoreType {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .base(visitBaseType(value.u.coretypebase_.basetype_))
    case 1:
        return .mulPair(visitType(value.u.coretypemulpair_.type_1), visitType(value.u.coretypemulpair_.type_2))
    case 2:
        return .sum(visitType(value.u.coretypesum_.type_1), visitType(value.u.coretypesum_.type_2))
    case 3:
        return .list(visitType(value.u.coretypelist_.type_))
    case 4:
        return .named(visitIdent(value.u.coretypenamed_.ident_), visitGenerics(value.u.coretypenamed_.generics_))
    case 5:
        return .function(visitListType(value.u.coretypefunction_.listtype_), visitType(value.u.coretypefunction_.type_))
    default:
        print("Error: bad `kind` field when bridging `CoreType` to Swift!")
        exit(1)
    }
}

private func visitIdMaybeTyped(_ pValue: CGrammar.IdMaybeTyped) -> IdMaybeTyped {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .notTyped(visitId(value.u.idmaybetypednottyped_.id_))
    case 1:
        return .typed(visitId(value.u.idmaybetypedtyped_.id_), visitType(value.u.idmaybetypedtyped_.type_))
    default:
        print("Error: bad `kind` field when bridging `IdMaybeTyped` to Swift!")
        exit(1)
    }
}

private func visitAssertion(_ pValue: CGrammar.Assertion) -> Assertion {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .typeEqual(visitId(value.u.assertiontypeequal_.id_), visitType(value.u.assertiontypeequal_.type_))
    default:
        print("Error: bad `kind` field when bridging `Assertion` to Swift!")
        exit(1)
    }
}

private func visitExp(_ pValue: CGrammar.Exp) -> Exp {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .int(visitInteger(value.u.expint_.integer_))
    case 1:
        return .double(visitDouble(value.u.expdouble_.double_))
    case 2:
        return .unit
    case 3:
        return .`true`
    case 4:
        return .`false`
    case 5:
        return .option(visitExp(value.u.expoption_.exp_))
    case 6:
        return .nothing
    case 7:
        return .id(visitId(value.u.expid_.id_))
    case 8:
        return .pair(visitExp(value.u.exppair_.exp_1), visitExp(value.u.exppair_.exp_2))
    case 9:
        return .sum(visitIdent(value.u.expsum_.ident_), visitCase(value.u.expsum_.case_), visitExp(value.u.expsum_.exp_))
    case 10:
        return .list(visitListExp(value.u.explist_.listexp_))
    case 11:
        return .ref(visitType(value.u.expref_.type_))
    case 12:
        return .app(visitId(value.u.expapp_.id_), visitListExp(value.u.expapp_.listexp_))
    case 13:
        return .noising(visitExp(value.u.expnoising_.exp_))
    case 14:
        return .negative(visitExp(value.u.expnegative_.exp_))
    case 15:
        return .not(visitExp(value.u.expnot_.exp_))
    case 16:
        return .times(visitExp(value.u.exptimes_.exp_1), visitExp(value.u.exptimes_.exp_2))
    case 17:
        return .div(visitExp(value.u.expdiv_.exp_1), visitExp(value.u.expdiv_.exp_2))
    case 18:
        return .plus(visitExp(value.u.expplus_.exp_1), visitExp(value.u.expplus_.exp_2))
    case 19:
        return .minus(visitExp(value.u.expminus_.exp_1), visitExp(value.u.expminus_.exp_2))
    case 20:
        return .lt(visitExp(value.u.explt_.exp_1), visitExp(value.u.explt_.exp_2))
    case 21:
        return .gt(visitExp(value.u.expgt_.exp_1), visitExp(value.u.expgt_.exp_2))
    case 22:
        return .ltEq(visitExp(value.u.explteq_.exp_1), visitExp(value.u.explteq_.exp_2))
    case 23:
        return .gtEq(visitExp(value.u.expgteq_.exp_1), visitExp(value.u.expgteq_.exp_2))
    case 24:
        return .eq(visitExp(value.u.expeq_.exp_1), visitExp(value.u.expeq_.exp_2))
    case 25:
        return .neq(visitExp(value.u.expneq_.exp_1), visitExp(value.u.expneq_.exp_2))
    default:
        print("Error: bad `kind` field when bridging `Exp` to Swift!")
        exit(1)
    }
}

private func visitListExp(_ pValue: CGrammar.ListExp?) -> [Exp] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.exp_ == nil {
        return []
    }
    return [visitExp(value.exp_)] + visitListExp(value.listexp_)
}

private func visitElse(_ pValue: CGrammar.Else) -> Else {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .none
    case 1:
        return .stms(visitListStm(value.u.elsestms_.liststm_))
    default:
        print("Error: bad `kind` field when bridging `Else` to Swift!")
        exit(1)
    }
}

private func visitGenerics(_ pValue: CGrammar.Generics) -> Generics {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .none
    case 1:
        return .type(visitType(value.u.genericstype_.type_))
    default:
        print("Error: bad `kind` field when bridging `Generics` to Swift!")
        exit(1)
    }
}

private func visitIfCond(_ pValue: CGrammar.IfCond) -> IfCond {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .`case`(visitIdMaybeTyped(value.u.ifcondcase_.idmaybetyped_), visitCase(value.u.ifcondcase_.case_), visitExp(value.u.ifcondcase_.exp_))
    case 1:
        return .bool(visitExp(value.u.ifcondbool_.exp_))
    case 2:
        return .unfold(visitIdMaybeTyped(value.u.ifcondunfold_.idmaybetyped_1), visitIdMaybeTyped(value.u.ifcondunfold_.idmaybetyped_2), visitExp(value.u.ifcondunfold_.exp_))
    default:
        print("Error: bad `kind` field when bridging `IfCond` to Swift!")
        exit(1)
    }
}

private func visitProgram(_ pValue: CGrammar.Program) -> Program {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .defs(visitListDef(value.u.programdefs_.listdef_))
    default:
        print("Error: bad `kind` field when bridging `Program` to Swift!")
        exit(1)
    }
}

private func visitStm(_ pValue: CGrammar.Stm) -> Stm {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .`init`(visitIdMaybeTyped(value.u.stminit_.idmaybetyped_), visitExp(value.u.stminit_.exp_))
    case 1:
        return .split(visitIdMaybeTyped(value.u.stmsplit_.idmaybetyped_1), visitIdMaybeTyped(value.u.stmsplit_.idmaybetyped_2), visitExp(value.u.stmsplit_.exp_))
    case 2:
        return .ifElse(visitIfCond(value.u.stmifelse_.ifcond_), visitListStm(value.u.stmifelse_.liststm_), visitElse(value.u.stmifelse_.else_))
    case 3:
        return .`switch`(visitExp(value.u.stmswitch_.exp_), visitListSwitchCase(value.u.stmswitch_.listswitchcase_))
    case 4:
        return .`return`(visitExp(value.u.stmreturn_.exp_))
    case 5:
        return .assert(visitAssertion(value.u.stmassert_.assertion_))
    default:
        print("Error: bad `kind` field when bridging `Stm` to Swift!")
        exit(1)
    }
}

private func visitListStm(_ pValue: CGrammar.ListStm?) -> [Stm] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.stm_ == nil {
        return []
    }
    return [visitStm(value.stm_)] + visitListStm(value.liststm_)
}

private func visitDef(_ pValue: CGrammar.Def) -> Def {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .fun(visitId(value.u.deffun_.id_), visitListArg(value.u.deffun_.listarg_), visitType(value.u.deffun_.type_), visitListStm(value.u.deffun_.liststm_))
    case 1:
        return .funExposed(visitId(value.u.deffunexposed_.id_), visitListArg(value.u.deffunexposed_.listarg_), visitType(value.u.deffunexposed_.type_), visitListStm(value.u.deffunexposed_.liststm_))
    case 2:
        return .typedef(visitIdent(value.u.deftypedef_.ident_), visitType(value.u.deftypedef_.type_1), visitType(value.u.deftypedef_.type_2))
    default:
        print("Error: bad `kind` field when bridging `Def` to Swift!")
        exit(1)
    }
}

private func visitListDef(_ pValue: CGrammar.ListDef?) -> [Def] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.def_ == nil {
        return []
    }
    return [visitDef(value.def_)] + visitListDef(value.listdef_)
}

private func visitBaseType(_ pValue: CGrammar.BaseType) -> BaseType {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .int
    case 1:
        return .unit
    case 2:
        return .double
    default:
        print("Error: bad `kind` field when bridging `BaseType` to Swift!")
        exit(1)
    }
}

private func visitType(_ pValue: CGrammar.`Type`) -> Type {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .initDouble(visitCoreType(value.u.typeinitdouble_.coretype_), visitDouble(value.u.typeinitdouble_.double_))
    case 1:
        return .initInt(visitCoreType(value.u.typeinitint_.coretype_), visitInteger(value.u.typeinitint_.integer_))
    case 2:
        return .exponential(visitCoreType(value.u.typeexponential_.coretype_))
    default:
        print("Error: bad `kind` field when bridging `Type` to Swift!")
        exit(1)
    }
}

private func visitListType(_ pValue: CGrammar.ListType?) -> [Type] {
    guard let value = pValue?.pointee else {
        return []
    }
    if value.type_ == nil {
        return []
    }
    return [visitType(value.type_)] + visitListType(value.listtype_)
}

private func visitCase(_ pValue: CGrammar.Case) -> Case {
    let value = pValue.pointee
    switch value.kind {
    case 0:
        return .inl
    case 1:
        return .inr
    default:
        print("Error: bad `kind` field when bridging `Case` to Swift!")
        exit(1)
    }
}

//MARK:- Tokens

private func visitIdent(_ pValue: CGrammar.Ident) -> Ident {
    return Ident(String(cString: pValue))
}

private func visitId(_ pValue: CGrammar.Id) -> Id {
    return Id(String(cString: pValue))
}

//MARK:- Default types

private func visitChar(_ pChar: CGrammar.Char) -> Swift.Character {
    return Swift.Character(Swift.UnicodeScalar(Swift.Int(pChar))!)
}

private func visitDouble(_ pDouble: CGrammar.Double) -> Swift.Double {
    return pDouble
}

private func visitInteger(_ pInteger: CGrammar.Integer) -> Swift.Int {
    return Swift.Int(pInteger)
}

private func visitString(_ pString: CGrammar.String) -> Swift.String {
    return Swift.String(cString: pString)
}
