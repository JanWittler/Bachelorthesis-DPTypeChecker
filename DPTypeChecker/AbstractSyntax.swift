//
//  Swift Abstract Syntax Interface generated by a custom BNF Converter from Jan Wittler
//
//  This converter assumes files generated with BNFC 2.8.1, GNU Bison 2.3 and Flex 2.5.35
//  Compatibility with other versions can not be guaranteed
//

public enum Arg {
    case decl(Id, Type)
}

public enum Assertion {
    case typeEqual(Id, Type)
}

public enum BaseType {
    case int
    case unit
    case double
}

public enum Case {
    case inl
    case inr
}

public indirect enum CoreType {
    case base(BaseType)
    case mulPair(Type, Type)
    case sum(Type, Type)
    case list(Type)
    case named(Ident, Generics)
    case function([Type], Type)
    //additional cases
    case unknown
}

public enum Def {
    case fun(Id, [Arg], Type, [Stm])
    case funExposed(Id, [Arg], Type, [Stm])
    case typedef(Ident, Type, Type)
}

public enum Else {
    case none
    case stms([Stm])
}

public indirect enum Exp {
    case int(Int)
    case double(Double)
    case unit
    case `true`
    case `false`
    case option(Exp)
    case nothing
    case id(Id)
    case pair(Exp, Exp)
    case sum(Ident, Case, Exp)
    case list([Exp])
    case ref(Type)
    case app(Id, [Exp])
    case noising(Exp)
    case negative(Exp)
    case not(Exp)
    case times(Exp, Exp)
    case div(Exp, Exp)
    case plus(Exp, Exp)
    case minus(Exp, Exp)
    case lt(Exp, Exp)
    case gt(Exp, Exp)
    case ltEq(Exp, Exp)
    case gtEq(Exp, Exp)
    case eq(Exp, Exp)
    case neq(Exp, Exp)
}

public enum Generics {
    case none
    case type(Type)
}

public enum IdMaybeTyped {
    case notTyped(Id)
    case typed(Id, Type)
}

public enum IfCond {
    case `case`(IdMaybeTyped, Case, Exp)
    case bool(Exp)
    case unfold(IdMaybeTyped, IdMaybeTyped, Exp)
}

public enum Program {
    case defs([Def])
}

public enum Stm {
    case `init`(IdMaybeTyped, Exp)
    case split(IdMaybeTyped, IdMaybeTyped, Exp)
    case ifElse(IfCond, [Stm], Else)
    case `switch`(Exp, [SwitchCase])
    case `return`(Exp)
    case assert(Assertion)
}

public enum SwitchCase {
    case `default`(IdMaybeTyped, Case, [Stm])
}

public enum Type {
    case initDouble(CoreType, Double)
    case initInt(CoreType, Int)
    case exponential(CoreType)
    //additional cases
    case `default`(CoreType, ReplicationIndex)
    case unknown
}

//MARK:- Tokens

public struct Id {
    public let value: String

    public init(_ value: String) {
        self.value = value
    }
}

public struct Ident {
    public let value: String

    public init(_ value: String) {
        self.value = value
    }
}

//MARK:- Custom printing

public protocol CustomAbstractSyntaxPrinting {
    func show() -> String
}

public extension CustomAbstractSyntaxPrinting {
    public func show() -> String {
        let description = String(reflecting: self)
        let moduleName = description.components(separatedBy: ".").first!
        return description.replacingOccurrences(of: "\(moduleName).", with: "")
    }
}

extension Arg: CustomAbstractSyntaxPrinting {
}

extension Assertion: CustomAbstractSyntaxPrinting {
}

extension BaseType: CustomAbstractSyntaxPrinting {
}

extension Case: CustomAbstractSyntaxPrinting {
}

extension CoreType: CustomAbstractSyntaxPrinting {
}

extension Def: CustomAbstractSyntaxPrinting {
}

extension Else: CustomAbstractSyntaxPrinting {
}

extension Exp: CustomAbstractSyntaxPrinting {
}

extension Generics: CustomAbstractSyntaxPrinting {
}

extension Id: CustomAbstractSyntaxPrinting {
}

extension IdMaybeTyped: CustomAbstractSyntaxPrinting {
}

extension Ident: CustomAbstractSyntaxPrinting {
}

extension IfCond: CustomAbstractSyntaxPrinting {
}

extension Program: CustomAbstractSyntaxPrinting {
}

extension Stm: CustomAbstractSyntaxPrinting {
}

extension SwitchCase: CustomAbstractSyntaxPrinting {
}

extension Type: CustomAbstractSyntaxPrinting {
}

//MARK:- Token helpers

extension Id: CustomStringConvertible {
    public var description: String { return "\(type(of: self))(\(String(reflecting: value)))" }
}

extension Id: Equatable {
    public static func ==(lhs: Id, rhs: Id) -> Bool {
        return lhs.value == rhs.value
    }
}

extension Id: Hashable {
    public var hashValue: Int { return value.hashValue }
}

extension Ident: CustomStringConvertible {
    public var description: String { return "\(type(of: self))(\(String(reflecting: value)))" }
}

extension Ident: Equatable {
    public static func ==(lhs: Ident, rhs: Ident) -> Bool {
        return lhs.value == rhs.value
    }
}

extension Ident: Hashable {
    public var hashValue: Int { return value.hashValue }
}
